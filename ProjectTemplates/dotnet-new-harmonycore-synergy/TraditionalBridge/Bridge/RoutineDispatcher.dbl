
import Json
import System.Collections
import TraditionalBridge

.define MaybeLog(priority, msg) if((priority) <= Logger.LogLevel) Logger.Instance.Log(msg)
;.define MaybeLog(priority, msg) Logger.Instance.Log(msg)

namespace Harmony.TraditionalBridge

    ;;; <summary>
    ;;; 
    ;;; </summary>
    public abstract class RoutineDispatcher

        ;;dummy structure for ^m operations on the mReadBuffer
        private structure MemStruct
            fld, a1
        endstructure

        protected mReadBuffer, D_HANDLE
        protected mReadBufferSize, int
        protected mDispatchStubs, @StringDictionary
        protected mActivationMask, [32]i1
.define GetBuffer ^m(MemStruct(1:mReadBufferSize), mReadBuffer)

        ;;; <summary>
        ;;; Constructor
        ;;; </summary>
        public method RoutineDispatcher
        proc
            mDispatchStubs = new StringDictionary()
            mReadBufferSize = 0
            mReadBuffer = 0
            MaybeLog(5, "Creating RoutineDispatcher")
        endmethod

        method ~RoutineDispatcher
        proc
            if(mReadBuffer != 0)
                mReadBuffer = %mem_proc(DM_FREE, mReadBuffer)

            mReadBufferSize = 0
            MaybeLog(5, "Destroying RoutineDispatcher")
        endmethod

        ;;; <summary>
        ;;; Deserialize a JSON object to a data object
        ;;; </summary>
        ;;; <param name="obj">JSON object to deserialize</param>
        ;;; <param name="targetType">Instance of a data object metadata class indicating the type to deserialize to</param>
        ;;; <returns>A data object of the appropriate type</returns>
        public virtual method DeserializeObject, @DataObjectBase
            obj, @JsonObject
            targetType, @DataObjectMetadataBase
            record
                passedValue, @JsonObject
                objectMetadata, @DataObjectMetadataBase
                objectType, @JsonText
            endrecord
        proc
            passedValue = (@JsonObject)obj.GetProperty("PassedValue")
            objectMetadata = targetType
            if(objectMetadata == ^null)
            begin
                objectType = (@JsonText)passedValue.GetProperty("Type")
                objectMetadata = DataObjectMetadataBase.LookupType(objectType.Value)
            end
            mreturn objectMetadata.Deserialize(passedValue)
        endmethod

        ;;Protocol note: this is another place where we need to decide how much we can ommit from the contents of collections
        ;;this is currently assuming we are only working with DataObjectBase

        ;;; <summary>
        ;;; Deserializes a JSON object containing a collection of serialized data objects into an ArrayList of data objects.
        ;;; Each of the data objects in the collection could be of a different type.
        ;;; </summary>
        ;;; <param name="obj">JSON object to deserialize</param>
        ;;; <returns>ArrayList containing data objects.</returns>
        public virtual method DeserializeObjectCollection, @ArrayList
            obj, @JsonObject
            record
                passedValue, @JsonArray
                elementValue, @JsonValue
                elementObject, @JsonObject
                objectMetadata, @DataObjectMetadataBase
                objectType, @JsonText
                result, @ArrayList
                elementIsEncoded, boolean
                elementTypeValue, @JsonValue
                isBriefEncoding, boolean
            endrecord
        proc
            isBriefEncoding = false
            result = new ArrayList()
            passedValue = (@JsonArray)obj.GetProperty("PassedValue")

            obj.TryGetBoolProperty("ElementIsEncoded", elementIsEncoded)
            if(obj.TryGetProperty("ElementType", elementTypeValue))
            begin
                isBriefEncoding = true
                objectMetadata = DataObjectMetadataBase.LookupType(((@JsonText)elementTypeValue).Value)
            end

            foreach elementValue in passedValue.arrayValues
            begin
                ;;TODO might be able to skip the lookup if the typename hasnt changed
                if(!isBriefEncoding) then
                begin
                    if(elementValue .is. @JsonObject) then 
                    begin
                        elementObject = (@JsonObject)elementValue
                        objectType = (@JsonText)elementObject.GetProperty("Type")
                        objectMetadata = DataObjectMetadataBase.LookupType(objectType.Value)
                        result.Add(objectMetadata.Deserialize(elementObject))
                    end
                    else if(elementValue .is. @JsonText) then
                    begin
                        result.Add(((@JsonText)elementValue).Value)
                    end
                    else if(elementValue .is. @JsonInt) then
                    begin
                        result.Add((@i)((@JsonInt)elementValue).Value)
                    end
                    else if(elementValue .is. @JsonNumber) then
                    begin
                        result.Add((@id)((@JsonNumber)elementValue).Value)
                    end
                    ;else if(elementValue .is. @JsonBoolean) then
                    ;  begin
                    ;	result.Add(((@JsonBoolean)elementValue).Value)
                    ;  end
                    else
                        throw new Exception("unknown collection encoding")
                end
                else if(elementIsEncoded) then
                begin
                    result.Add(objectMetadata.MakeNew(Convert.FromBase64String(((@JsonText)elementValue).Value), ""))
                end
                else
                begin
                    result.Add(objectMetadata.MakeNew(((@JsonText)elementValue).Value, ""))
                end
            end
            mreturn result
        endmethod

        ;;; <summary>
        ;;; 
        ;;; </summary>
        ;;; <param name="memoryHandle"></param>
        ;;; <param name="collection"></param>
        public method UnwrapObjectCollection, void
            memoryHandle, i4
            collection, @ArrayList
        proc
                        
        endmethod

        public method UnwrapObjectCollection, void
            dataDef, @ArgumentDataDefinition
            jsonArray, @JsonArray
            arrayList, @ArrayList
        proc

        endmethod

        ;;this needs to take an expected type parameter of some kind so we can do basic conversions int -> decimal vs int -> int

        ;;; <summary>
        ;;; 
        ;;; </summary>
        ;;; <param name="buffer"></param>
        ;;; <param name="elementInfo"></param>
        ;;; <param name="bufferPosition"></param>
        ;;; <param name="collection"></param>
        public method UnwrapObjectCollection, void
            inout buffer, a
            elementInfo, @ArgumentDataDefinition
            inout bufferPosition, i
            collection, @JsonArray
            record
                element, @JsonValue
            endrecord
        proc
            foreach element in collection.arrayValues
            begin
                if(element .is. JsonObject) then
                begin
                    data valueToken, @JsonValue
                    data stringValue, @string
                    if(((@JsonObject)element).TryGetProperty("Value", valueToken)) then
                    begin
                        stringValue = ((@JsonText)valueToken).Value
                    end
                    else
                    begin
                        stringValue = Convert.FromBase64String(((@JsonText)((@JsonObject)element).GetProperty("Base64Value")).Value)
                    end
                    buffer(bufferPosition:elementInfo.ElementSize) = stringValue
                end
                else if(element .is. JsonText) then
                begin
                    buffer(bufferPosition:elementInfo.ElementSize) = ((@JsonText)element).Value
                end
                else if(element .is. JsonNumber) then
                begin
                    ^d(buffer(bufferPosition:elementInfo.ElementSize), elementInfo.DecimalPrecision) = ((@JsonNumber)element).Value
                end
                else if(element .is. JsonInt) then
                begin
                    if(elementInfo.DataType == FieldDataType.IntegerField) then
                        ^i(buffer(bufferPosition:elementInfo.ElementSize)) = ((@JsonInt)element).Value
                    else
                        ^d(buffer(bufferPosition:elementInfo.ElementSize), elementInfo.DecimalPrecision) = %string(((@JsonInt)element).Value)
                end
                else if(element .is. JsonBoolean) then
                begin
                                        
                end
                else if(element .is. JsonArray)
                begin

                end
                bufferPosition += elementInfo.ElementSize
            end

        endmethod

        public method UnwrapObjectCollection, void
            handle, D_HANDLE
            elementInfo, @ArgumentDataDefinition
            inout bufferPosition, i
            collection, @JsonArray
            record
                element, @JsonValue
            endrecord
            structure localStr
                fld, a1
            endstructure

        proc
            foreach element in collection.arrayValues
            begin
                if(element .is. JsonObject) then
                begin
                    data valueToken, @JsonValue
                    data stringValue, @string
                    if(((@JsonObject)element).TryGetProperty("Value", valueToken)) then
                    begin
                        stringValue = ((@JsonText)valueToken).Value
                    end
                    else
                    begin
                        stringValue = Convert.FromBase64String(((@JsonText)((@JsonObject)element).GetProperty("Base64Value")).Value)
                    end
                    MaybeLog(6, "filling handle bufferPosition: " + %string(bufferPosition) + " elementSize: " + %string(elementInfo.ElementSize))
                    ^m(localStr.fld(bufferPosition:elementInfo.ElementSize), handle) = stringValue
                end
                else if(element .is. JsonText) then
                begin
                    ^m(localStr.fld(bufferPosition:elementInfo.ElementSize), handle) = ((@JsonText)element).Value
                end
                else if(element .is. JsonNumber) then
                begin
                    ^d(^m(localStr.fld(bufferPosition:elementInfo.ElementSize), handle), elementInfo.DecimalPrecision) = ((@JsonNumber)element).Value
                end
                else if(element .is. JsonInt) then
                begin
                    if(elementInfo.DataType == FieldDataType.IntegerField) then
                        ^i(^m(localStr.fld(bufferPosition:elementInfo.ElementSize), handle)) = ((@JsonInt)element).Value
                    else
                        ^d(^m(localStr.fld(bufferPosition:elementInfo.ElementSize), handle), elementInfo.DecimalPrecision) = %string(((@JsonInt)element).Value)
                end
                else if(element .is. JsonBoolean) then
                begin
                                        
                end
                else if(element .is. JsonArray)
                begin

                end
                bufferPosition += elementInfo.ElementSize
            end

        endmethod

        ;;; <summary>
        ;;; 
        ;;; </summary>
        ;;; <param name="argument"></param>
        ;;; <returns></returns>
        public method GetArgumentDataDefForCollection, @ArgumentDataDefinition
            argument, @JsonObject
            in optional elementSize, int
            record
                result, @ArgumentDataDefinition
                dataType, i4
            endrecord
        proc
            result = new ArgumentDataDefinition()
            result.ElementSize = elementSize

            argument.TryGetProperty("DecimalPrecision", result.DecimalPrecision)
            argument.TryGetProperty("ElementSize", result.ElementSize)
            if(argument.TryGetProperty("DataType", dataType))
                result.DataType = (FieldDataType)dataType

            argument.TryGetBoolProperty("ReturnedValue", result.ReturnedValue)

            mreturn result

        endmethod

        ;;TODO: This needs to take an expected type parameter of some kind so we can do basic conversions int -> decimal vs int -> int

        public method UnwrapObjectCollection, @ArrayList
            collection, @JsonArray
            record
                result, @ArrayList
                buffer, a65535
        proc
            result = new ArrayList()
            UnwrapObjectCollection(collection, result, false, ^null, buffer)
            mreturn result
        endmethod

        private method UnwrapJsonValue, @object
            element, @JsonValue
            elementIsEncoded, boolean
            elementType, @DataObjectMetadataBase
            inout elementBuffer, a
            optional desiredType, FieldDataType
            optional desiredSize, int
            optional desiredPrecision, int
            optional grfa, a
        proc
            if(element .is. JsonText) then
            begin
                if(^passed(desiredSize)) then
                begin
                    if(!^passed(desiredType)) then
                    begin
                        elementBuffer(1: desiredSize) = ((@JsonText)element).Value
                        mreturn (@*)elementBuffer(1: desiredSize)
                    end
                    else if(desiredType == FieldDataType.DataObjectField) then
                    begin
                        elementBuffer(1: desiredSize) = ((@JsonText)element).Value
                        if(^passed(grfa)) then
                            mreturn elementType.MakeNew(elementBuffer(1: desiredSize), grfa)
                        else
                            mreturn elementType.MakeNew(elementBuffer(1: desiredSize), "")
                    end
                    else if(desiredType == FieldDataType.StringField) then
                    begin
                        mreturn ((@JsonText)element).Value
                    end
                    else if(desiredType == FieldDataType.AlphaField)
                    begin
                        elementBuffer(1: desiredSize) = ((@JsonText)element).Value
                        mreturn (@*)elementBuffer(1: desiredSize)
                    end
                end
                else
                begin
                    mreturn (@a)(a)((@JsonText)element).Value
                end
            end
            else if(element .is. JsonNumber) then
            begin
                if(!^passed(desiredType)) then
                begin
                    ^d(elementBuffer(1: 28), 10) = ((@JsonNumber)element).Value 
                    mreturn (@*)^d(elementBuffer(1: 28), 10)
                end
                else if(desiredType == FieldDataType.IntegerField) then
                begin
                    ^i(elementBuffer(1: desiredSize)) = ((@JsonNumber)element).Value 
                    mreturn (@*)^i(elementBuffer(1: desiredSize))
                end
                else if(desiredType == FieldDataType.DecimalField) then
                begin
                    ^d(elementBuffer(1: desiredSize)) = ((@JsonNumber)element).Value
                    mreturn (@*)^d(elementBuffer(1: desiredSize))
                end
                else if(desiredType == FieldDataType.ImpliedDecimal) then
                begin
                    ^d(elementBuffer(1: desiredSize), desiredPrecision) = ((@JsonNumber)element).Value
                    mreturn (@*)^d(elementBuffer(1: desiredSize), desiredPrecision)
                end
                else
                    throw new Exception("invalid desired type " + %string(desiredType))
            end
            else if(element .is. JsonInt) then
            begin
                if(!^passed(desiredType)) then
                begin
                    ^i(elementBuffer(1: 8)) = ((@JsonInt)element).Value 
                    mreturn (@*)^i(elementBuffer(1: 8))
                end
                else if(desiredType == FieldDataType.IntegerField) then
                begin
                    ^i(elementBuffer(1: desiredSize)) = ((@JsonInt)element).Value 
                    mreturn (@*)^i(elementBuffer(1: desiredSize))
                end
                else if(desiredType == FieldDataType.DecimalField) then
                begin
                    ^d(elementBuffer(1: desiredSize)) = ((@JsonInt)element).Value
                    mreturn (@*)^d(elementBuffer(1: desiredSize))
                end
                else if(desiredType == FieldDataType.ImpliedDecimal) then
                begin
                    ^d(elementBuffer(1: desiredSize), desiredPrecision) = ((@JsonInt)element).Value
                    mreturn (@*)^d(elementBuffer(1: desiredSize), desiredPrecision)
                end
                else
                    throw new Exception("invalid desired type " + %string(desiredType))
            end
            else if(element .is. JsonBoolean)
            begin
                mreturn (@boolean)((@JsonBoolean)element).Value
            end
        endmethod

        ;;; <summary>
        ;;; 
        ;;; </summary>
        ;;; <param name="elementInfo"></param>
        ;;; <param name="collection"></param>
        ;;; <param name="targetArrayList"></param>
        public method UnwrapObjectCollection, void
            collection, @JsonArray
            ;;must be an arraylist or a typed dynamic array
            targetCollection, @Array
            elementIsEncoded, boolean
            elementType, @DataObjectMetadataBase
            inout elementBuffer, a
            optional desiredType, FieldDataType
            optional desiredSize, int
            optional desiredPrecision, int
            record
                element, @JsonValue
                index, int
            endrecord
        proc
            if(targetCollection.Length != collection.arrayValues.Count)
                throw new Exception("Dynamic array must be correctly sized before unwrapping object collection into it")
            index = 1

            foreach element in collection.arrayValues
            begin
                if(element .is. JsonObject) then
                begin
                    data valueToken, @JsonValue
                    if(((@JsonObject)element).TryGetProperty("Value", valueToken)) then
                    begin
                        if(elementType != ^null && ^passed(desiredType) && desiredType == FieldDataType.AlphaField) then
                            elementType.SetIntoArray((@a)UnwrapJsonValue(valueToken, false, elementType, elementBuffer, desiredType, desiredSize, desiredPrecision), targetCollection, index)
                        else
                            targetCollection.SetValue(UnwrapJsonValue(valueToken, false, elementType, elementBuffer, desiredType, desiredSize, desiredPrecision), index)
                    end
                    else
                    begin
                        targetCollection.SetValue(UnwrapJsonValue(((@JsonObject)element).GetProperty("Base64Value"), true, elementType, elementBuffer, desiredType, desiredSize, desiredPrecision), index)
                    end
                end
                else
                begin
                    if(elementType != ^null && ^passed(desiredType) && desiredType == FieldDataType.AlphaField) then
                        elementType.SetIntoArray((@a)UnwrapJsonValue(element, false, elementType, elementBuffer, desiredType, desiredSize, desiredPrecision), targetCollection, index)
                    else
                        targetCollection.SetValue(UnwrapJsonValue(element, false, elementType, elementBuffer, desiredType, desiredSize, desiredPrecision), index)
                end
                incr index
            end
        endmethod

        public method UnwrapObjectCollection, void
            collection, @JsonArray
            ;;must be an arraylist or a typed dynamic array
            targetCollection, @ArrayList
            elementIsEncoded, boolean
            elementType, @DataObjectMetadataBase
            inout elementBuffer, a
            optional desiredType, FieldDataType
            optional desiredSize, int
            optional desiredPrecision, int
            record
                element, @JsonValue
            endrecord
        proc
            foreach element in collection.arrayValues
            begin
                if(element .is. JsonObject) then
                begin
                    data valueToken, @JsonValue
                    if(((@JsonObject)element).TryGetProperty("Value", valueToken)) then
                    begin
                        targetCollection.Add(UnwrapJsonValue(valueToken, false, elementType, elementBuffer, desiredType, desiredSize, desiredPrecision))
                    end
                    else
                    begin
                        targetCollection.Add(UnwrapJsonValue(((@JsonObject)element).GetProperty("Base64Value"), true, elementType, elementBuffer, desiredType, desiredSize, desiredPrecision))
                    end
                end
                else
                begin
                    targetCollection.Add(UnwrapJsonValue(element, false, elementType, elementBuffer, desiredType, desiredSize, desiredPrecision))
                end
            end
        endmethod

        public method UnwrapStringArray, [#]@string
            collection, @JsonArray
            record
                result, [#]@string
                element, @JsonValue
                i, int
            endrecord
        proc
            i = 1
            result = new String[collection.arrayValues.Count]
            foreach element in collection.arrayValues
            begin
                if(element .is. JsonText) then
                begin
                    result[i] = ((@JsonText)element).Value
                end
                else
                    throw new InvalidCastException()
                incr i
            end
            mreturn result
        endmethod

        public method UnwrapIntArray, [#]int
            collection, @JsonArray
            record
                result, [#]int
                element, @JsonValue
                i, int
        proc
            i = 1
            result = new int[collection.arrayValues.Count]
            foreach element in collection.arrayValues
            begin
                if(element .is. JsonInt) then
                begin
                    result[i] = ((@JsonInt)element).Value
                end
                else
                    throw new InvalidCastException()
                incr i
            end
            mreturn result
        endmethod

        public method UnwrapBoolArray, [#]boolean
            collection, @JsonArray
            record
                result, [#]boolean
                element, @JsonValue
                i, int
        proc
            i = 1
            result = new boolean[collection.arrayValues.Count]
            foreach element in collection.arrayValues
            begin
                if(element .is. JsonBoolean) then
                begin
                    result[i] = ((@JsonBoolean)element).Value
                end
                else
                    throw new InvalidCastException()
                incr i
            end
            mreturn result
        endmethod

        public method UnwrapImpliedDecimalArray, [#]@id
            collection, @JsonArray
            record
                result, [#]@id
                element, @JsonValue
                i,      int
        proc
            i = 1
            result = new @id[collection.arrayValues.Count]
            foreach element in collection.arrayValues
            begin
                if(element .is. JsonNumber) then
                begin
                    result[i] = (@id)((@JsonNumber)element).Value
                end
                else
                    throw new InvalidCastException()
                incr i
            end
            mreturn result
        endmethod

        ;;; <summary>
        ;;; 
        ;;; </summary>
        ;;; <param name="value"></param>
        ;;; <returns></returns>
        public method GetText, a
            value, @JsonObject
            record
                valueText, @JsonText
            endrecord
        proc
            valueText = (@JsonText)value.GetProperty("PassedValue")
            mreturn valueText.Value
        endmethod

        ;;; <summary>
        ;;; 
        ;;; </summary>
        ;;; <param name="value"></param>
        ;;; <returns></returns>
        public method GetInt, i
            value, @JsonObject
            record
                valueInt, @JsonInt
            endrecord
        proc
            valueInt = (@JsonInt)value.GetProperty("PassedValue")
            mreturn valueInt.Value
        endmethod

        public method GetArray, @JsonArray
            value, @JsonObject
            record
                valueArray, @JsonArray
            endrecord
        proc
            valueArray = (@JsonArray)value.GetProperty("PassedValue")
            mreturn valueArray
        endmethod

        ;;; <summary>
        ;;; 
        ;;; </summary>
        ;;; <param name="value"></param>
        ;;; <returns></returns>
        public method GetDecimal, d
            value, @JsonObject
            record
                passedValue, @JsonValue
                valueInt, @JsonInt
                valuestring, @JsonText
                tempD, d28
            endrecord
        proc
            passedValue = value.GetProperty("PassedValue")
            if(passedValue.JsonType == JSON_TYPE.INT_VAL ) then
            begin
                valueInt = (@JsonInt)passedValue
                tempD = valueInt.Value
                mreturn tempD
            end
            else
            begin
                valuestring = (@JsonText)passedValue
                mreturn ^d((a)valuestring.Value)
            end
        endmethod

        ;;; <summary>
        ;;; 
        ;;; </summary>
        ;;; <param name="value"></param>
        ;;; <returns></returns>
        public method GetImplied, d.
            value, @JsonObject
            record
                passedValue, @JsonValue
                valueInt, @JsonInt
                precisionValue, @JsonValue
                precisionInt, @JsonInt
                valuestring, @JsonText
                tempD, d56.28
            endrecord
        proc
            passedValue = value.GetProperty("PassedValue")

            precisionValue = value.GetProperty("DecimalPrecision")
            precisionInt = (@JsonInt)precisionValue

            if(passedValue.JsonType == JSON_TYPE.INT_VAL ) then
            begin
                valueInt = (@JsonInt)passedValue
                tempD = ^d(%string(valueInt.Value),precisionInt.Value)
                mreturn tempD
            end
            else
            begin
                valuestring = (@JsonText)passedValue
                mreturn %implied((a)valuestring.Value)
            end
        endmethod

        ;;; <summary>
        ;;; 
        ;;; </summary>
        ;;; <param name="obj"></param>
        ;;; <param name="dataType"></param>
        ;;; <returns></returns>
        public method DeserializeObject, @object
            obj, @JsonObject
            out dataType, FieldDataType
            record
                dataTypeInt, @JsonInt
                propValue, @JsonValue
            endrecord
        proc
            dataTypeInt = ((@JsonInt)obj.GetProperty("DataType"))
            dataType = (FieldDataType)dataTypeInt.Value
            if(dataType == FieldDataType.DataObjectField) then
            begin
                mreturn DeserializeObject(obj, ^null)
            end
            else if(dataType == FieldDataType.DataObjectCollectionField) then
            begin
                mreturn DeserializeObjectCollection(obj)
            end
            else
            begin
                obj.TryGetProperty("PassedValue", propValue)
                if(dataType == FieldDataType.AlphaField) then
                begin
                    if(propValue == ^null) then
                        mreturn (@object)""
                    else
                    begin
                        data textObject, @JsonText, ((@JsonText)propValue)
                        mreturn textObject.Value
                    end
                end
                else if(dataType == FieldDataType.DecimalField) then
                begin
                    if(propValue == ^null) then
                    begin
                        mreturn (@object)"0"
                    end
                    else
                    begin
                        mreturn ((@JsonText)propValue).Value
                    end
                end
                else if(dataType == FieldDataType.ImpliedDecimal) then
                begin
                    if(propValue == ^null) then
                    begin
                        mreturn (@object)"0"
                    end
                    else
                    begin
                        mreturn ((@JsonText)propValue).Value
                    end
                end
                else if(dataType == FieldDataType.IntegerField)
                begin
                    data intValue, i4, 0
                    if(propValue != ^null)
                        intValue = ((@JsonInt)propValue).Value
                                
                    mreturn (@object)intValue
                end
            end

        endmethod

        ;;; <summary>
        ;;; 
        ;;; </summary>
        ;;; <param name="ttChannel"></param>
        ;;; <param name="frameHeader"></param>
        ;;; <returns></returns>
        private method ReadCallBlock, boolean
            required in ttChannel, i
            required in frameHeader, i4
            required in leftovers, a
            required in leftoversLength, i
            record
                jsonReader, @Json
                parsedJson, @JsonValue
                serializer, @DispatchSerializer
                result, boolean
                readerPosition, int
                remainingRead, int
                constrainedRemainingRead, int
                innerString, @string
                innerHandle, D_HANDLE
            endrecord
        proc
            jsonReader = new Json()
            serializer = new DispatchSerializer(new ChannelOutputStream(ttChannel))
            ;;reuse the same buffer if possible
            if(mReadBufferSize < frameHeader)
            begin
                if(mReadBuffer != 0) then
                begin
                    MaybeLog(6, "Dispatcher: reallocating buffer was " + %string(mReadBufferSize) + " -> " + %string(frameHeader) )
                    mReadBuffer = %mem_proc(DM_RESIZ, frameHeader, mReadBuffer)
                    mReadBufferSize = frameHeader
                end
                else
                begin
                    MaybeLog(6, "Dispatcher: allocating buffer with length" + %string(frameHeader))
                    mReadBuffer = %mem_proc(DM_ALLOC | DM_STATIC, frameHeader)
                    mReadBufferSize = frameHeader
                end
            end

            MaybeLog(6, "Dispatcher: Reading " + %string(frameHeader) + " total bytes of Content from input" )
            readerPosition = 1 + leftoversLength
            remainingRead = frameHeader - leftoversLength

            if(leftoversLength > 0)
            begin
                ;;workaround for non conforming io on newlines
                decr(remainingRead)
                ^m(MemStruct(1:leftoversLength), mReadBuffer) = leftovers(1:leftoversLength)
            end


            do 
            begin
                MaybeLog(6, "Dispatcher: Reading " + %string(remainingRead) + " bytes from input")
                if(remainingRead > 65535) then
                    constrainedRemainingRead = 65535
                else
                    constrainedRemainingRead = remainingRead
                gets(ttChannel, ^m(MemStruct(readerPosition:constrainedRemainingRead), mReadBuffer), wait:100, MASK:mActivationMask) [$ERR_TIMOUT=again]
            again,  
                MaybeLog(7, "Dispatcher: Reading Content from input" + ^m(MemStruct(readerPosition:remainingRead), mReadBuffer) + ": got " + %string(%rdlen(ttChannel)) + " bytes, was expecting " + %string(remainingRead) + " bytes")
                readerPosition += %rdlen(ttChannel)
                remainingRead = frameHeader - readerPosition
                                
            end
            until remainingRead <= 0

            if(frameHeader > 64000) then
                MaybeLog(6, "Dispatcher: Parsing buffer " + ^m(MemStruct(1:64000), mReadBuffer))
            else
                MaybeLog(6, "Dispatcher: Parsing buffer " + ^m(MemStruct(1:frameHeader), mReadBuffer))
            ;innerHandle = %mem_proc(DM_REG, readerPosition - 1, ^addr(^m(MemStruct(1:1), mReadBuffer)))
            innerString = %string_from_handle(mReadBuffer)
            parsedJson = jsonReader.ParseJson(innerString.Substring(0, readerPosition - 1))
            if (!(parsedJson .is. @JsonObject) && !(parsedJson .is. @JsonArray))
            begin
				serializer.ReportError("failed to parse json request", (int)-32700, (int)-1)
                mreturn true
            end

            MaybeLog(5, "Dispatcher: Finished Json Parsing")

            result = true
            if(parsedJson .is. JsonObject) then
            begin
                MaybeLog(5, "Dispatcher: Single Call")
                result = ProcessCallBlock((@JsonObject)parsedJson, serializer)
            end
            else if(parsedJson .is. JsonArray)
            begin
                data parsedArray, @JsonArray
                data jsonVal, @JsonValue
                parsedArray = (@JsonArray)parsedJson

                MaybeLog(5, "Dispatcher: Batch Call")

                serializer.ArrayOpen()
                foreach jsonVal in parsedArray.arrayValues
                begin
                    if(jsonVal .is. JsonObject) then
                    begin
                        result = ProcessCallBlock((@JsonObject)parsedJson, serializer)
                        if(!result)
                            exitloop
                    end
                    else
                    begin
						serializer.ReportError("failed to parse json request", (int)-32700, (int)-1)
                    end
				end
                serializer.ArrayClose()
			end
			serializer.Flush()
            flush(ttChannel)
            mreturn result

        endmethod

        ;;; <summary>
        ;;; 
        ;;; </summary>
        ;;; <param name="ttChannel"></param>
        public method Dispatch, void
            ttChannel, i
            record PacketLength
                contentLengthPart, a16
                lengthValue, a10
                padding, a2
            endrecord
            record ContentType
                contentTypeBuffer, a255
            endrecord
            record
                leftoverData, a1
                leftoverLength, int
                lengthReadPos, int
            record
                running, boolean
                frameHeader, d10
                contentTypePos, int
                contentTypeLength, int
            endrecord
        proc
            ;;read 10 bytes of data from input when its available
            ;;read count of bytes from input (in chunks ideally) 
            ;;look for the target routine name
            ;;build rcb block for the call
            ;;deserialize arguments based on the types in json
            ;;make the call
            ;;trap any exceptions
            try
            begin
                running = true
                while(running)
                begin
                    clear ContentType
                    clear PacketLength
                    lengthReadPos = 1
                    do 
                    begin
                        gets(ttChannel, PacketLength(lengthReadPos:1), wait:100, MASK:mActivationMask)  [$ERR_TIMOUT=again]
                        contentTypeLength = %rdlen(ttChannel)
                                                                                                
                        if(contentTypeLength != 1)
                            MaybeLog(5, "Dispatcher: got zero length from single char read without timeout")
                                                                                                
                        lengthReadPos += contentTypeLength
                    again,          
                        
                    end
                    until lengthReadPos > 16 && PacketLength(lengthReadPos - 1:1) == %char(10)

                    MaybeLog(6, "Dispatcher: Reading ContentLength from input" + %atrim(PacketLength) + ":" + %string(lengthReadPos))

                    clear PacketLength(lengthReadPos - 2:2)
                    frameHeader = ^d(%atrim(lengthValue))
                    contentTypePos = 1
                    while(contentTypePos < 255)
                    begin
                    againContent,   
                        gets(ttChannel, ContentType(contentTypePos:1), wait:100, MASK:mActivationMask)  [$ERR_TIMOUT=againContent]
                        ;;if(contentTypePos > 3 && ContentType(contentTypePos:1) == %char(10))
                        ;;begin
                        ;;        leftoverLength = 0
                        ;;        exitloop
                        ;;end

                        if(ContentType(contentTypePos:1) == '{')
                        begin
                            leftoverData = '{'
                            leftoverLength = 1
                            exitloop
                        end

                        contentTypePos += %rdlen(ttChannel)
                    end

                    MaybeLog(6, "Dispatcher: Reading ContentType from input" + %atrim(ContentType) + ":" + %string(contentTypePos))

                    MaybeLog(5, "Dispatcher: starting callblock processing with ContentLength " + %atrim(lengthValue) + " ContentType " + %atrim(ContentType))

                    running = ReadCallBlock(ttChannel, (int)frameHeader + 1, leftoverData, leftoverLength)
                    Logger.Instance.FinishMemoryLog()
                end
                MaybeLog(1, "Shutting down due to running == false")
            end
            catch(ex, @Exception)
            begin
                try
                begin
                    data serializer = new DispatchSerializer(new ChannelOutputStream(ttChannel))
					serializer.ReportError(ex.ToString(), (int)-32603, (int)-1)
                end
                catch(ex2, @Exception)
                begin
                    MaybeLog(1, "failed while writing error " + ex2.ToString() + " original error was " + ex.ToString())
                    Logger.Instance.CloseLog()
                end
                endtry
            end
            endtry
        endmethod

        ;;; <summary>
        ;;; 
        ;;; </summary>
        ;;; <param name="jsonData"></param>
        ;;; <param name="responseChannel"></param>
        ;;; <returns></returns>
        public method ProcessCallBlock, boolean
            jsonData, @JsonObject
            serializer, @DispatchSerializer
            record
                requestId, int
                name, @string
                argArrayList, @ArrayList
                dispatchStub, @RoutineStub
            endrecord
        proc
                        
            if(!jsonData.TryGetProperty("id", requestId))
                requestId = -1

            if(!jsonData.TryGetProperty("method", name))
            begin
				serializer.ReportError("method name missing", (int)-32600, requestId)
            end

            MaybeLog(5, "Dispatcher: method target was " + name)

            serializer.OutputScopeOpen()

            try
            begin
                if(name.StartsWith("rpc.")) then
                begin
                    if(name == "rpc.shutdown") then
                    begin
                        ;;we've been asked to shutdown so return false and let the outer loop take care of it
						serializer.ReportResult(requestId, 0)
                        serializer.OutputScopeClose()
                        mreturn false
                    end
                    else if(name == "rpc.ping") then
                    begin
						serializer.ReportResult(requestId, 0)
                    end
                    else if(name == "rpc.serializer_protocol") then
                    begin
						serializer.ReportResult(requestId, "1.0")
                    end
                    else if(name == "rpc.set_log_level") then
                    begin
                        data logArg, @JsonInt
                        argArrayList = ((@JsonArray)jsonData.GetProperty("params")).arrayValues

                        if(argArrayList.Count != 1 || !(argArrayList[0] .is. JsonObject)) then
							serializer.ReportError("invalid parameters for rpc.set_log_level", (int)-32602, requestId)
                        else
                        begin
                            data settingsArgumentData = (@JsonObject)argArrayList[0] 
                            data passedValueProp = settingsArgumentData.GetProperty("PassedValue")
                            data passedValue = (@JsonObject)passedValueProp
                            data targetLogSettings = new LoggerScopeSettings()
                            if(passedValue == ^null)
								serializer.ReportError("invalid parameters for rpc.set_log_level", (int)-32602, requestId)

                            passedValue.TryGetProperty("ScopeIdentifier", targetLogSettings.ScopeIdentifier)
                            passedValue.TryGetProperty("LogLocation", targetLogSettings.LogLocation)
                            if(!(passedValue.TryGetBoolProperty("LogToMemory", targetLogSettings.LogToMemory) &&
                            &    passedValue.TryGetBoolProperty("LogToDisk", targetLogSettings.LogToDisk) &&
                            &    passedValue.TryGetBoolProperty("FlushLog", targetLogSettings.FlushLog) &&
                            &    passedValue.TryGetProperty("OnDiskLogLevel", targetLogSettings.OnDiskLogLevel) &&
                            &    passedValue.TryGetProperty("InMemoryLogLevel", targetLogSettings.InMemoryLogLevel) &&
                            &    passedValue.TryGetBoolProperty("AttachLogsToExceptions", targetLogSettings.AttachLogsToExceptions)))
                                Logger.Instance.Log("incomplete log settings object was passed")

                            Logger.Instance.SetRootScope(targetLogSettings)

							serializer.ReportResult(requestId, 0)
                        end

                    end
                    else if(name == "rpc.chain") then
                    begin
                        ;;TODO: flush everything out and stop chain to ourselves
						serializer.ReportError("rpc.chain not yet implemented", -32603, requestId)
                    end
                    else
                    begin
                        ;;extension method was called but isnt supported
						serializer.ReportError("unknown extension method", -32601, requestId)
                    end
                end
                else
                begin
                    if(mDispatchStubs.TryGet(name, dispatchStub)) then
                    begin
                        MaybeLog(5, "Dispatcher: dispatching compiled stub for " + name)
                        dispatchStub.Dispatch(name, jsonData, serializer, this)
                        MaybeLog(5, "Dispatcher: finished dispatching compiled stub for " + name)
                    end
                    else
                    begin
                        throw new RoutineNotFound(name + " was not found")
                    end
                end
                serializer.OutputScopeClose()
            end
            catch(rtnNotFound, @RoutineNotFound)
            begin
                serializer.OutputScopeAbort()
				serializer.ReportError(rtnNotFound.ToString(), -32601, requestId)
            end
            catch(ex, @Exception)
            begin
                serializer.OutputScopeAbort()
                ;;TODO maybe this should be a specific type, we might need to do additional processing for certain exception types here
				serializer.ReportError(ex.ToString(), -32000, requestId)
            end
            endtry

            mreturn true
        endmethod
    endclass

    ;;; <summary>
    ;;; 
    ;;; </summary>
    abstract class RoutineStub
                
        ;;; <summary>
        ;;; 
        ;;; </summary>
        ;;; <param name="name"></param>
        ;;; <param name="callFrame"></param>
        ;;; <param name="serializer"></param>
        ;;; <param name="dispatcher"></param>
        protected abstract method DispatchInternal, void
            name, @string
            callFrame, @JsonObject
            serializer, @DispatchSerializer
            dispatcher, @RoutineDispatcher
        proc

		endmethod

		public method Dispatch, void
			name, @string
			callFrame, @JsonObject
			serializer, @DispatchSerializer
			dispatcher, @RoutineDispatcher
			record
				requestId, int
		proc
			serializer.ReportResponseProlog(callFrame.TryGetProperty("id", requestId), requestId)
			DispatchInternal(name, callFrame, serializer, dispatcher)
			serializer.ReportResponseEpilog()
		endmethod

        public method RCBInit, void
            required in targetMethod, a
            required in argumentCount, int
            required inout existingHandle, D_HANDLE
        proc
            MaybeLog(5, "Dispatcher: dispatching RCB for " + targetMethod)
            if(existingHandle) then
                nop
            else
                existingHandle = %rcb_create(argumentCount, DM_STATIC)

            xcall rcb_setfnc(existingHandle, targetMethod)
        endmethod

        public method RCBArg, void
            index, int
            argObject, @JsonObject
            argType, FieldDataType
            inout argBuffer, a
            rcbid, D_HANDLE
            argBufferPrecision, int
            optional out passed, boolean
            record
                argLength, i4
                argPrecision, i4
                argValue, @JsonValue
                argIsEncoded, boolean
        proc
            argLength = ^size(argBuffer)
            argPrecision = 0

            if(argObject.TryGetProperty("PassedValue", argValue)) then
            begin
                if(^passed(passed))
                    passed = true

                if(!argObject.TryGetBoolProperty("ElementIsEncoded", argIsEncoded))
                    argIsEncoded = false

                if(argType != FieldDataType.DataObjectField && argType != FieldDataType.DataObjectCollectionField) then
                begin
                    data elementSizeValue, @JsonValue
                    if(argObject.HasProperty("DecimalPrecision"))
                        argPrecision = ((@JsonInt)argObject.GetProperty("DecimalPrecision")).Value

                    if(argType == FieldDataType.AlphaField) then
                    begin
                        if(argIsEncoded) then
                            argBuffer = Convert.FromBase64String(((@JsonText)argValue).Value)
                        else
                            argBuffer = ((@JsonText)argValue).Value
                    end
                    else if(argType == FieldDataType.DecimalField) then
                    begin
                        if(argValue .is. JsonNumber) then
                        begin
                            MaybeLog(4, "argument " + %string(index) + " passed to rcb dispatcher with argType " + %string(argType) + " JsonNumber value " + %string(((@JsonNumber)argValue).Value))
                            ^d(argBuffer) = ((@JsonNumber)argValue).Value
                        end
                        else if(argValue .is. JsonInt)
                        begin
                            MaybeLog(4, "argument " + %string(index) + " passed to rcb dispatcher with argType " + %string(argType) + " and arglength " + %string(argLength) + " JsonInt value " + %string(((@JsonInt)argValue).Value))
                            ^d(argBuffer) = %implied(((@JsonInt)argValue).Value)
                        end
                    end
                    else if(argType == FieldDataType.ImpliedDecimalField) then
                    begin
                        if(argValue .is. JsonNumber) then
                            ^d(argBuffer, argBufferPrecision) = ((@JsonNumber)argValue).Value
                        else if(argValue .is. JsonInt)
                            ^d(argBuffer, argBufferPrecision) = %implied(((@JsonInt)argValue).Value)
                    end
                    else if(argType == FieldDataType.IntegerField) then
                    begin
                        MaybeLog(4, "argument " + %string(index) + " passed to rcb dispatcher with argType " + %string(argType)  + " and arglength " + %string(argLength) + " JsonInt value " + %string(((@JsonInt)argValue).Value))
                        ^i(argBuffer) = ((@JsonInt)argValue).Value
                    end

                    else
                        throw new Exception("unexpected arg type during RCB dispatch " + %string(argType))

                    MaybeLog(4, "argument " + %string(index) + " passed to rcb dispatcher with argType " + %string(argType) + " argBuffer value " + argBuffer)
                    xcall rcb_setarg(rcbid, argBuffer, index, (i)argType, argLength, argPrecision)
                end
                else
                    throw new Exception("Object parameters to RCB dispatch is not currently implemented")
            end
            else
            begin
                if(^passed(passed))
                    passed = false
                MaybeLog(4, "argument " + %string(index) + " was not passed to rcb dispatcher")
            end

        endmethod
		
        public method RCBSerializeArg, void
            index, int
            passed, boolean
            argType, FieldDataType
            argBuffer, a
            argLength, i4
            argPrecision, i4
            serializer, @DispatchSerializer
        proc
            MaybeLog(4, "RCBSerializeArg: serializing argType " + %string(argType) + " marked as passed: " + %string(passed) + " with buffer " + argBuffer)

            if(passed)
            begin
                case (argType) of
                begincase
                FieldDataType.AlphaField:
                    serializer.ArgumentData(index, argBuffer, argType, argLength, argPrecision, false)
                FieldDataType.IntegerField:
                    serializer.ArgumentData(index, ^i(argBuffer), argType, argLength, argPrecision, false)
                FieldDataType.ImpliedDecimalField:
                    serializer.ArgumentData(index, ^d(argBuffer, argPrecision), argType, argLength, argPrecision, false)
                FieldDataType.DecimalField:
                    serializer.ArgumentData(index, ^d(argBuffer), argType, argLength, argPrecision, false)
                endcase
            end
        endmethod
    endclass


    class SuperRoutineDispatcher extends RoutineDispatcher
        public method SuperRoutineDispatcher
            dispatchers, [#]@RoutineDispatcher
            record
                dispatcher, @RoutineDispatcher
        proc
            foreach dispatcher in dispatchers
            begin
                MergeStringDictionary(dispatcher.mDispatchStubs)
            end
        endmethod

        private method MergeStringDictionary, void
            dict, @StringDictionary
            record
                kvp, @StringDictionary.KeyValuePair
        proc
            foreach kvp in dict.Items()
            begin
                if (!mDispatchStubs.Contains(kvp.Key)) then
                begin
                    MaybeLog(5, "SuperRoutineDispatcher: adding dispatcher " + kvp.Key)
                    mDispatchStubs.Add(kvp.Key, kvp.Value)
                end
                else
                    MaybeLog(5, "SuperRoutineDispatcher: Skipping dispatcher. Already exists: " + kvp.Key)
            end

        endmethod


    endclass
endnamespace
